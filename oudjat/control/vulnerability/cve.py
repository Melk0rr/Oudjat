"""A module to describe security vulnerabilities."""

import datetime
import re
from typing import Dict, List, Union

from oudjat.connectors.vuln import CVEConnector, CVEDatabase
from oudjat.utils.color_print import ColorPrint

from .definitions import CVE_REGEX
from .severity import Severity


class CVE:
    """
    A class to handle vulnerabilities.
    """

    # ****************************************************************
    # Attributes & Constructors

    def __init__(
        self,
        ref: str,
        cvss: float = 0,
        date: Union[str, datetime.datetime] = None,
        description: str = None,
    ) -> None:
        """
        Create a new instance of CVE.

        Args:
            ref (str)             : CVE ref (CVE-YYYY-XXXXX)
            cvss (float)          : CVSS score of the CVE
            date (str | datetime) : publish date of the CVE
            description (str)     : CVE description
        """

        if not self.check_ref(ref):
            raise ValueError(f"{__class__.__name__}::{ref} is not a valid CVE id")

        self.ref: str = ref

        self.cvss: float = 0
        self.set_cvss(float(cvss))
        self.severity: Severity = Severity.INFO

        # self.link: str = NistConnector.get_cve_url(self.ref)
        self.link: str = None

        self.status: str = None
        self.publish_date: datetime = date
        self.description: str = description
        self.references: List[str] = []

        self.connector: CVEConnector = None

    # ****************************************************************
    # Getters and Setters

    def get_ref(self) -> str:
        """
        Return the CVE reference.

        Return:
            str : CVE ref
        """

        return self.ref

    def get_cvss(self) -> float:
        """
        Return the CVSS score.

        Return:
            float : CVE CVSS score
        """

        return self.cvss

    def get_severity(self) -> str:
        """
        Return the severity.

        Return:
            str : CVE severity
        """

        return self.severity.name

    def get_link(self) -> str:
        """
        Return CVE link.

        Return:
            str : CVE link
        """

        return self.link

    def set_cvss(self, cvss_score: float) -> None:
        """
        Set the vulnerability CVSS score.

        Args:
            cvss_score (float) : new CVSS score
        """

        if CVE.check_cvss(cvss_score):
            self.cvss = cvss_score
            self.resolve_severity()

        else:
            ColorPrint.red(
                f"{cvss_score} is not a valid CVSS score. You must provide a value between 0 and 10"
            )

    def set_from_dict(self, cve_dict: Dict) -> None:
        """
        Set CVE informations from dictionary.

        Args:
            cve_dict (Dict) : cve dictionary
        """

        self.cvss = cve_dict.get("cvss")
        self.publish_date = cve_dict.get("publish_date", "")
        self.description = cve_dict.get("description", "")

    def set_connector(self, cve_db: CVEDatabase) -> None:
        """
        Use a CVEDatabase enum element to initialize CVE connector.

        Args:
            cve_db (CVEDatabase): cve database that will be used to initialize connector
        """

        self.connector = cve_db.connector()

    def copy(self, cve: "CVE") -> None:
        """
        Copy the given cve informations.

        Args:
            cve (CVE) : cve to copy
        """

        self.set_from_dict(cve.to_dict(minimal=False))
        print(self)

    # ****************************************************************
    # Resolvers

    def resolve_severity(self) -> None:
        """Resolve the severity based on the CVSS score."""

        self.severity = Severity.from_cvss(self.cvss)

    # ****************************************************************
    # Parsers

    def connector_parse(self, cve_db: CVEDatabase = None) -> None:
        """
        Parse CVE data from a CVEConnector.

        Args:
            cve_db (CVEDatabase): If not none, the provided cve database will be used to replace the current connector
        """

        if self.connector is None and cve_db is None:
            raise Exception(f"{__class__.__name__}.connector_parse::Connector is not initialized !")

        elif cve_db is not None:
            self.set_connector(cve_db)

        cve_data = self.connector.search(search_filter=self.ref)
        self.set_cvss(cve_data["metrics"]["score"])
        # TODO: finish setting up attributes from cve data

    def parse_nist(self, verbose: bool = False) -> None:
        """
        Parse NIST CVE page in order to retrieve CVE data.

        Args:
            verbose (bool) : enable verbose mode
        """

        nist_search = self.nist_connector.search(search_filter=self.ref, attributes=self.NIST_ATTR)

        nist_data = None
        if len(nist_search) == 0:
            return

        nist_data = nist_search[0]

        self.status = nist_data["vulnStatus"]
        self.publish_date = nist_data["published"]
        self.description = nist_data["descriptions"][0]["value"]

        metrics = nist_data["metrics"]

        if len(list(metrics)) > 0:
            metric_data = metrics[list(metrics)[0]][0]
            cvss_data = metric_data["cvssData"]

            self.set_cvss(cvss_data["baseScore"])

        self.references = [r["url"] for r in nist_data["references"]]

        if verbose:
            print(self)

    # ****************************************************************
    # Converters

    def __str__(self, show_severity: bool = False) -> str:
        """
        Convert the current instance to a string.

        Args:
            show_severity (bool) : wheither to show the CVE severity

        Return:
            str : CVE string
        """

        base = f"{self.ref} ({self.cvss})"

        if show_severity:
            base += f"({self.severity.name})"

        return base

    def to_dict(self) -> Dict:
        """
        Convert the current instance to a dictionary.

        Return:
            Dict: CVE converted to a dictionary
        """

        return {
            "ref": self.ref,
            "cvss": self.cvss,
            "published": self.publish_date,
            "status": self.status,
            "description": self.description,
            "link": self.link,
            "references": self.references,
        }

    # ****************************************************************
    # Static methods

    @staticmethod
    def check_ref(cve_ref: str) -> bool:
        """
        Check whether the given cve id is valid.

        Args:
            cve_ref (str) : CVE ref

        Return:
            bool : wheither the CVE ref is valid or not
        """

        return re.match(CVE_REGEX, cve_ref)

    @staticmethod
    def check_cvss(cvss_score: float) -> bool:
        """
        Check whether the given cvss score is valid.

        Args:
            cvss_score (float) : CVSS score

        Return:
            bool : wheither or not the CVSS score is valid
        """

        return 0 <= cvss_score <= 10

    @staticmethod
    def create_from_dict(cve_dict: Dict) -> "CVE":
        """
        Create a CVE instance from a dictionary.

        Args:
            cve_dict (Dict) : CVE dictionary

        Return:
            CVE : cve instance
        """

        return CVE(
            ref=cve_dict.get("ref"),
            cvss=cve_dict.get("cvss"),
            date=cve_dict.get("publish_date", ""),
            description=cve_dict.get("description", ""),
        )

    @staticmethod
    def find_cve_by_ref(ref: str, cve_list: List["CVE"]) -> "CVE":
        """
        Find a CVE instance by ref in a list of CVEs.

        Args:
            ref (str)            : CVE ref
            cve_list (List[CVE]) : list of CVE to search in

        Return:
            CVE : cve instance based on provided ref
        """

        if not CVE.check_ref(ref):
            raise ValueError(f"{__class__.__name__}.find_cve_by_ref::Invalid CVE reference provided: {ref}")

        return next(filter(CVE.cve_ref_is, cve_list, [ref] * len(cve_list)))

    @staticmethod
    def cve_ref_is(cve: "CVE", value: str) -> bool:
        """
        Check if the provided CVE ref is equal to the given value.
        """

        return cve.get_ref() == value

    # TODO: implement SQLi database
    @staticmethod
    def resolve_cve_data(cves: List["CVE"], cve_data: List["CVE"] = None) -> None:
        """
        Resolve CVE data for all related CVE.

        Args:
            cves (List[CVE])     : list of CVE instances to resolve information from Nist API
            cve_data (List[CVE]) : a list of CVE instances to use as information base
        """

        print(f"\nResolving {len(cves)} CVEs data...")

        for cve in cves:
            # Checks if the current CVE can be found in the provided cve list. If not : parse Nist page
            cve_imported = False
            if cve_data is not None:
                cve_search = CVE.find_cve_by_ref(ref=cve.get_ref(), cve_list=cve_data)

                if cve_search:
                    print(f"Found {cve.get_ref()} in CVE list ! Copying data...")
                    cve.copy(cve_search)
                    cve_imported = True

            if not cve_imported:
                cve.parse_nist(verbose=False)

    @staticmethod
    def max_cve(cves: List["CVE"]) -> List["CVE"]:
        """
        Return the highest(s) cve(s).

        Args:
            cves (List[CVE]) : list of CVE to check

        Return:
            List[CVE] : sub list of the provided argument list with the highest CVSS score
        """

        if len(cves) == 0 or cves is None:
            print("No comparison possible: no CVE related")
            return None

        print(f"\nResolving most critical CVEs among {len(cves)} provided")

        max_cve = max(cves, key=lambda cve: cve.get_cvss())

        if max_cve is not None:
            max_cve = [cve for cve in cves if cve.get_cvss() == max_cve.get_cvss()]

        print("\nMax CVEs are:")
        for cve in max_cve:
            print(cve)

        return max_cve

